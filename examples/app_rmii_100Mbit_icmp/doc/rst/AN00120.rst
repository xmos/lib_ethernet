
|newpage|

#############################
100Mbit Ethernet RMII example
#############################

********
Overview
********

The application note shows the use of the XMOS Ethernet library. The
library allows multiple clients to access the Ethernet hardware.
This application note uses the real-time RMII MAC which uses
four cores and provides high performance streaming data, accurate
packet timestamping, priority queuing and 802.1Qav traffic shaping.

RMII provides the data transfer signals
between the Ethernet PHY (Physical Layer Device or transceiver) and
the xCORE device. The RMII layer receives packets of data which are
then routed by an Ethernet MAC layer to multiple processes running on
the xCORE. SMI provides the management interface between the PHY and
the xCORE device.

The application communicates with the Ethernet MAC that drives the RMII
data interface to the PHY. A separate PHY driver configures the PHY
via the SMI serial interface. The application is tested on the ``xk_eth_xu316_dual_100m``
board which is an xcore.ai based board. It also has two `TI DP83826E <https://www.ti.com/product/DP83826E>`_ PHYs
connected to it and can run applications requiring up to two ethernet ports.
This application instantiates one RMII MAC port that connects to one of the two
DP83826E PHYs on the board.


*************************
100Mbit RMII ICMP example
*************************


Building the Application
========================

The following section assumes you have downloaded and installed the `XMOS XTC tools <https://www.xmos.com/software-tools/>`_
(see `README` for required version). Installation instructions can be found `here <https://xmos.com/xtc-install-guide>`_.
Be sure to pay attention to the section `Installation of required third-party tools
<https://www.xmos.com/documentation/XM-014363-PC-10/html/installation/install-configure/install-tools/install_prerequisites.html>`_.

The application uses the `xcommon-cmake <https://www.xmos.com/file/xcommon-cmake-documentation/?version=latest>`_
build system as bundled with the XTC tools.

The file `CMakeLists.txt` contains the application build configuration.

To configure the build run the following from an XTC command prompt::

    cd app_rmii_100Mbit_icmp
    cmake -G "Unix Makefiles" -B build

Any missing dependencies will be downloaded by the build system as part of this configure step.

Finally, the application binaries can be built using ``xmake``::

    xmake -C build

This will build the application binary ``app_rmii_100Mbit_icmp.xe`` in the ``app_rmii_100Mbit_icmp/bin`` directory.

The example uses the MAC layer implementation in the ``lib_ethernet`` library. It depends on
``lib_board_support`` for the PHY configuration on the ``xk_eth_xu316_dual_100m`` board.
It also gets the MAC address out of the xCORE OTP ROM, and depends on ``lib_otpinfo`` for that.

These dependencies are specified in the ``deps.cmake`` file, which is included in the application ``CMakeLists.txt``

Allocating hardware resources
=============================

The Ethernet library requires several ports to communicate with the
Ethernet PHY. These ports are declared in the main program file
(``main.xc``). In this examples the ports are set up for the PHY 1 on the ``xk_eth_xu316_dual_100m``
board.

Actual port names such as ``XS1_PORT_1A`` are specified in XN file and source refers
to them with symbolic names such as ``PHY_0_TX_EN``, with the actual to symbolic name mapping
specified in the xn file:

.. literalinclude:: ../../src/main.xc
   :start-at: rmii_data_port_t
   :end-at: PHY_0_TX_EN

In addition to the ports, two clock blocks are required, one each for the ethernet TX and RX clocks.

.. literalinclude:: ../../src/main.xc
   :start-at: eth_rxclk
   :end-at: eth_txclk


The MDIO Serial Management Interface (SMI) is used to transfer
management information between MAC and PHY. This interface consists of
two signals which are connected to two ports:

.. literalinclude:: ../../src/main.xc
   :start-at: p_smi_mdio
   :end-at: p_smi_mdc

The final ports used in the application are the ones to access the internal OTP
memory on the xCORE. These ports are fixed and can be intialized with
the ``OTP_PORTS_INITIALIZER`` macro supplied by the ``lib_otpinfo``
OTP reading library.

.. literalinclude:: ../../src/main.xc
   :start-at: // These ports are for accessing the OTP memory
   :end-at: otp_ports

The application main() function
===============================

The main function in the program sets up the tasks in the application.

.. literalinclude:: ../../src/main.xc
   :start-at: int main
   :end-before: return 0;

The ``rmii_ethernet_rt_mac`` creates a 100M RMII MAC instance that connects to the PHY on board.
It internally starts the four tasks, ``rmii_master_rx_pins_4b``, ``rmii_master_tx_pins``, ``mii_ethernet_filter``
and ``mii_ethernet_server``, that make up the MAC implementation.
These tasks handle communicating with the PHY at the pin level (``rmii_master_rx_pins_4b``, ``rmii_master_tx_pins``),
filtering received packets based on a MAC address lookup table based filtering, moving them
into the receive queues ((``mii_ethernet_filter``) and communicating with the client processes,
facilitating packet transfer between the clients and the network (``mii_ethernet_server``).

The ``rmii_ethernet_rt_mac`` tasks takes the previously declared ports as arguments as well as the required buffer size for the packet
buffer within the MAC.

The ``smi`` task is part of the Ethernet library and controls the SMI protocol to configure the PHY.
It connects to the ``dp83826e_phy_driver`` task which connects configuration of the PHY.

The ``dp83826e_phy_driver`` function is implemented in ``lib_board_support`` and it configures the PHY
over the SMI interface.

The IP address that the ICMP code uses is declared as an array in ``main.xc``::

   static unsigned char ip_address[4] = {192, 168, 1, 178};

This value can be altered to something that works on a given network.

|newpage|

The PHY driver
==============

The PHY drive task ``dp83826e_phy_driver`` connects to both the Ethernet MAC (via the
``ethernet_cfg_if`` interface for configuration) and the SMI driver
(via the ``smi_if`` interface):

.. literalinclude:: ../../src/main.xc
   :start-at: on tile[1]: dp83826e_phy_driver
   :end-at:  p_smi_mdc);

The first action the drive does is wait for the PHY to power up and
then configure the PHY. This is done via library functions provided by
the Ethernet library.

The main body of the drive is an infinite loop that periodically
reacts to a timer event in an xC ``select`` statement. After a set period
it checks the state of the PHY over SMI and then informs the MAC of
this state via the ``i_eth.set_link_state`` call. This way the MAC can
know about link up/down events or change of link speed.

ICMP packet processing
=======================

The packet processing in the application is handled by the
``icmp_server`` task which is defined in the file ``icmp.xc``. This
function connects to the ethernet MAC via a transmit, receive and
configuration interface:

.. literalinclude:: ../../src/icmp.xc
   :start-at: [[combinable]]
   :end-at: {

The first thing the task performs is configuring its connection to the
MAC. The MAC address is configured by reading a MAC address out of OTP
(using the ``otp_board_info_get_mac`` function from the OTP reading
library) and then calling the ``set_macaddr`` interface function:

.. literalinclude:: ../../src/icmp.xc
   :start-at: unsigned char mac_address[MACADDR_NUM_BYTES];
   :end-at: cfg.set_macaddr

After this, the task configures filters to determine which type of
packets is will receive from the MAC:

.. literalinclude:: ../../src/icmp.xc
   :start-at: memcpy(macaddr_filter.addr
   :end-before: debug_printf

The task then proceeds into an infinite loop that waits for a packet
from the MAC and then processes it:

.. literalinclude:: ../../src/icmp.xc
   :start-at: while (1)

The xC ``select`` statement will wait for the event
``rx.packet_ready()`` which is a receive notification from the MAC
(see the Ethernet library user guide for details of the ethernet
receive interface). When a packet arrives the ``rx.get_packet`` call
will retreive the packet from the MAC.

After the packet is processed the ``tx.send_packet`` call will send
the created reponse packet to the MAC.

Details of the packet processing functions ``is_valid_arp_packet``,
``build_arp_response``, ``is_valid_icmp_packet`` and
``build_icmp_response`` can be found in the ``icmp.xc`` file. The
functions implement the ICMP protocol.

|newpage|

Demo Hardware Setup
===================

TODO


Running the application
=======================

Once the ``app_rmii_100Mbit_icmp.xe`` application binary is compiled, it can be
executed on the ``xk_eth_xu316_dual_100m`` board.

The ``xrun`` tool is used from the command line to download and run the code on the xCore device.
In a terminal with XTC tools sourced, from the ``app_rmii_100Mbit_icmp`` directory, run::

   xrun bin/app_rmii_100Mbit_icmp.xe

Once this command has executed hte application will be running on the xCore device.


|newpage|

****
FAQs
****

TODO

|newpage|

***************
Further reading
***************

* XMOS XTC Tools Installation Guide

   https://xmos.com/xtc-install-guide

   * XMOS XTC Tools User Guide

      https://www.xmos.com/view/Tools-15-Documentation

   * XMOS application build and dependency management system; xcommon-cmake

      https://www.xmos.com/file/xcommon-cmake-documentation/?version=latest


 * XMOS Layer 2 Ethernet MAC Component

   https://www.xmos.com/published/xmos-layer-2-ethernet-mac-component


 * Ethernet Frame

   http://en.wikipedia.org/wiki/Ethernet_frame


 * MAC address

   http://en.wikipedia.org/wiki/MAC_address

 * Ethernet Type

   http://en.wikipedia.org/wiki/EtherType

 * Internet Control Message Protocol

   http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol

|newpage|


